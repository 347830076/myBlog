## 作用域

作用域是可访问变量的集合。

## 全局作用域

JavaScript 全局变量

变量在函数外定义，即为全局变量。

全局变量有 全局作用域: 网页中所有脚本和函数均可使用。 

```js
var carName = " Volvo";
// 此处可调用 carName 变量
console.log(carName, 1);
function myFunction() {
    // 函数内可调用 carName 变量
    console.log(carName, 2);
}
```

如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。

以下实例中 carName 在函数内，但是为全局变量。

```js
function myFunction() {
    carName = "Volvo";
    // 此处可调用 carName 变量
    console.log(carName, 2);
}
myFunction();
  // 此处可调用 carName 变量
console.log(carName, 1);
```

```js
var a = '我在window对象上,我是全局作用域';
let a = '我也是全局作用域，可我不在window对象上';
const a = '我也是全局作用域，可我也不在window对象上';
```

> 全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。

## 局部作用域

变量在函数内部

```js
function fun() {
    var a = '我是局部作用域a';
    let b = '我是局部作用域b';
}
//这里不能访问
console.log(a);  //Uncaught ReferenceError: a is not defined
console.log(b);  //Uncaught ReferenceError: b is not defined
```

JavaScript 变量生命周期

JavaScript 变量生命周期在它声明时初始化。

局部变量在函数执行完毕后销毁。

全局变量在页面关闭后销毁。

## 函数参数

函数参数只在函数内起作用，是局部变量。

## 块级作用域

在 ES6 之前，是没有块级作用域的概念的。
```js
for(var i = 0; i < 5; i++) {
}
console.log(i);
```
很明显，用 var 关键字声明的变量，在 for 循环之后i仍然被保存全局作用域里

这可以说明： for() { } 仍然在，全局作用域里，并没有产生像函数作用域一样的封闭效果；

如果想要实现 **块级作用域** 那么我们需要用 let 关键字声明！！！

```js
for(let i = 0; i < 5; i++) {
}
console.log(i); // 报错：ReferenceError: i is not defined
```
在 for 循环执行完毕之后 i 变量就被释放了，它已经消失了！！！

同样能形成块级作用域的还有 **const** 关键字：

```js
if (true) {
  const a = 'inner';
}
console.log(a);				// 报错：ReferenceError: a is not defined
```

## 作用域链

#### 1.什么是自由变量

首先认识一下什么叫做 自由变量 。如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。

```js
var a = 100
function fn() {
    var b = 200
    console.log(a) // 这里的a在这里就是一个自由变量
    console.log(b)
}
fn();
```

#### 2.什么是作用域链

如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。

```js
var a = 100
function F1() {
    var b = 200
    function F2() {
        var c = 300
        console.log(a) // 自由变量，顺作用域链向父作用域找
        console.log(b) // 自由变量，顺作用域链向父作用域找
        console.log(c) // 本作用域的变量
    }
    F2()
}
F1()
```

#### 3.关于自由变量的取值

关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。

```js
var x = 10
function fn() {
    console.log(x)
}
function show(f) {
    var x = 20;
    fn() //10，而不是20
}
show();
```

在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到**创建fn函数的那个作用域中取**，无论fn函数将在哪里调用。

所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:**要到创建这个函数的那个域**”。
**作用域中取值,这里强调的是“创建”，而不是“调用”，**切记切记——其实这就是所谓的"静态作用域"

```js
var a = 10;
function fn() {
  var b = 20;
  function bar() {
    console.log(a + b); //30
  }
  return bar;
}
var x = fn(),b = 200;
x(); //bar()
```
fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30

## 作用域与执行上下文

许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。

我们知道JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：

### 解释阶段（预解析）：

- 词法分析
- 语法分析
- 作用域规则确定

### 执行阶段（执行代码）：

- 创建执行上下文
- 执行函数代码
- 垃圾回收

JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是：

**执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。**

一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。
